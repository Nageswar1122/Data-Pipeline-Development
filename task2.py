# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O2D6WtQGuPpdzyY6h2HOwZL_x9yQwh6Z
"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers, Sequential
from tensorflow.keras.datasets import cifar10, imdb
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.utils import to_categorical
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import classification_report, confusion_matrix
import pandas as pd
import warnings
warnings.filterwarnings('ignore')

# Set random seeds for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

class DeepLearningProject:
    """
    A comprehensive deep learning project implementing both image classification
    and natural language processing models using TensorFlow/Keras.
    """

    def __init__(self):
        """Initialize the deep learning project."""
        self.img_model = None
        self.nlp_model = None
        self.img_history = None
        self.nlp_history = None
        self.img_data = {}
        self.nlp_data = {}
        self.class_names_img = ['airplane', 'automobile', 'bird', 'cat', 'deer',
                               'dog', 'frog', 'horse', 'ship', 'truck']

        print("üöÄ Deep Learning Project Initialized!")
        print("üìä Available Models: Image Classification (CIFAR-10) & NLP (IMDB Reviews)")

    def load_and_preprocess_image_data(self):
        """
        Load and preprocess CIFAR-10 dataset for image classification.
        """
        print("\n" + "="*60)
        print("üñºÔ∏è  LOADING AND PREPROCESSING IMAGE DATA (CIFAR-10)")
        print("="*60)

        # Load CIFAR-10 dataset
        (x_train, y_train), (x_test, y_test) = cifar10.load_data()

        print(f"üìä Training images: {x_train.shape}")
        print(f"üìä Training labels: {y_train.shape}")
        print(f"üìä Test images: {x_test.shape}")
        print(f"üìä Test labels: {y_test.shape}")

        # Normalize pixel values to range [0, 1]
        x_train = x_train.astype('float32') / 255.0
        x_test = x_test.astype('float32') / 255.0

        # Convert labels to categorical (one-hot encoding)
        y_train = to_categorical(y_train, 10)
        y_test = to_categorical(y_test, 10)

        # Store data
        self.img_data = {
            'x_train': x_train,
            'y_train': y_train,
            'x_test': x_test,
            'y_test': y_test
        }

        print("‚úÖ Image data preprocessed successfully!")
        print(f"üìä Normalized pixel range: [{x_train.min():.2f}, {x_train.max():.2f}]")
        print(f"üìä Labels shape after one-hot encoding: {y_train.shape}")

        # Visualize sample images
        self.visualize_sample_images()

    def visualize_sample_images(self):
        """Visualize sample images from CIFAR-10 dataset."""
        plt.figure(figsize=(15, 6))
        plt.suptitle('Sample CIFAR-10 Images', fontsize=16, fontweight='bold')

        for i in range(10):
            plt.subplot(2, 5, i + 1)
            # Find first occurrence of each class
            class_idx = np.where(np.argmax(self.img_data['y_train'], axis=1) == i)[0][0]
            plt.imshow(self.img_data['x_train'][class_idx])
            plt.title(f'{self.class_names_img[i]}', fontsize=10)
            plt.axis('off')

        plt.tight_layout()
        plt.show()

    def build_cnn_model(self):
        """
        Build a Convolutional Neural Network for image classification.
        """
        print("\nüîß Building CNN Model for Image Classification...")

        self.img_model = Sequential([
            # First Convolutional Block
            layers.Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)),
            layers.BatchNormalization(),
            layers.Conv2D(32, (3, 3), activation='relu'),
            layers.MaxPooling2D((2, 2)),
            layers.Dropout(0.25),

            # Second Convolutional Block
            layers.Conv2D(64, (3, 3), activation='relu'),
            layers.BatchNormalization(),
            layers.Conv2D(64, (3, 3), activation='relu'),
            layers.MaxPooling2D((2, 2)),
            layers.Dropout(0.25),

            # Third Convolutional Block
            layers.Conv2D(128, (3, 3), activation='relu'),
            layers.BatchNormalization(),
            layers.Dropout(0.25),

            # Fully Connected Layers
            layers.Flatten(),
            layers.Dense(512, activation='relu'),
            layers.BatchNormalization(),
            layers.Dropout(0.5),
            layers.Dense(10, activation='softmax')
        ])

        # Compile the model
        self.img_model.compile(
            optimizer='adam',
            loss='categorical_crossentropy',
            metrics=['accuracy']
        )

        print("‚úÖ CNN Model built successfully!")
        print("\nüìã Model Architecture:")
        self.img_model.summary()

        return self.img_model

    def train_image_model(self, epochs=20, batch_size=32):
        """
        Train the CNN model on CIFAR-10 dataset.
        """
        print(f"\nüöÄ Training CNN Model for {epochs} epochs...")

        # Data augmentation
        datagen = keras.preprocessing.image.ImageDataGenerator(
            rotation_range=15,
            width_shift_range=0.1,
            height_shift_range=0.1,
            horizontal_flip=True
        )
        datagen.fit(self.img_data['x_train'])

        # Callbacks
        callbacks = [
            keras.callbacks.EarlyStopping(patience=5, restore_best_weights=True),
            keras.callbacks.ReduceLROnPlateau(factor=0.5, patience=3, min_lr=0.0001)
        ]

        # Train the model
        self.img_history = self.img_model.fit(
            datagen.flow(self.img_data['x_train'], self.img_data['y_train'],
                        batch_size=batch_size),
            epochs=epochs,
            validation_data=(self.img_data['x_test'], self.img_data['y_test']),
            callbacks=callbacks,
            verbose=1
        )

        print("‚úÖ CNN Model training completed!")

        # Evaluate model
        test_loss, test_accuracy = self.img_model.evaluate(
            self.img_data['x_test'], self.img_data['y_test'], verbose=0
        )
        print(f"üéØ Final Test Accuracy: {test_accuracy:.4f}")
        print(f"üéØ Final Test Loss: {test_loss:.4f}")

    def load_and_preprocess_nlp_data(self, max_features=10000, max_length=500):
        """
        Load and preprocess IMDB movie reviews dataset for sentiment analysis.
        """
        print("\n" + "="*60)
        print("üìù LOADING AND PREPROCESSING NLP DATA (IMDB Reviews)")
        print("="*60)

        # Load IMDB dataset
        (x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=max_features)

        print(f"üìä Training reviews: {len(x_train)}")
        print(f"üìä Test reviews: {len(x_test)}")
        print(f"üìä Vocabulary size: {max_features}")

        # Pad sequences to ensure uniform length
        x_train = pad_sequences(x_train, maxlen=max_length)
        x_test = pad_sequences(x_test, maxlen=max_length)

        # Store data
        self.nlp_data = {
            'x_train': x_train,
            'y_train': y_train,
            'x_test': x_test,
            'y_test': y_test,
            'max_features': max_features,
            'max_length': max_length
        }

        print("‚úÖ NLP data preprocessed successfully!")
        print(f"üìä Padded sequence shape: {x_train.shape}")
        print(f"üìä Label distribution: Positive: {np.sum(y_train)}, Negative: {len(y_train) - np.sum(y_train)}")

        # Visualize sequence lengths
        self.visualize_sequence_lengths()

    def visualize_sequence_lengths(self):
        """Visualize distribution of sequence lengths in the dataset."""
        # Load original data to get sequence lengths
        (x_train_orig, _), (x_test_orig, _) = imdb.load_data()

        train_lengths = [len(seq) for seq in x_train_orig[:1000]]  # Sample for visualization

        plt.figure(figsize=(12, 4))

        plt.subplot(1, 2, 1)
        plt.hist(train_lengths, bins=50, alpha=0.7, color='skyblue', edgecolor='black')
        plt.title('Distribution of Sequence Lengths (Sample)')
        plt.xlabel('Sequence Length')
        plt.ylabel('Frequency')

        plt.subplot(1, 2, 2)
        plt.boxplot(train_lengths)
        plt.title('Sequence Length Box Plot')
        plt.ylabel('Sequence Length')

        plt.tight_layout()
        plt.show()

    def build_lstm_model(self):
        """
        Build an LSTM model for sentiment analysis.
        """
        print("\nüîß Building LSTM Model for Sentiment Analysis...")

        self.nlp_model = Sequential([
            # Embedding layer
            layers.Embedding(self.nlp_data['max_features'], 128,
                           input_length=self.nlp_data['max_length']),
            layers.Dropout(0.2),

            # LSTM layers
            layers.LSTM(128, return_sequences=True, dropout=0.2, recurrent_dropout=0.2),
            layers.LSTM(64, dropout=0.2, recurrent_dropout=0.2),

            # Dense layers
            layers.Dense(32, activation='relu'),
            layers.Dropout(0.5),
            layers.Dense(1, activation='sigmoid')
        ])

        # Compile the model
        self.nlp_model.compile(
            optimizer='adam',
            loss='binary_crossentropy',
            metrics=['accuracy']
        )

        print("‚úÖ LSTM Model built successfully!")
        print("\nüìã Model Architecture:")
        self.nlp_model.summary()

        return self.nlp_model

    def train_nlp_model(self, epochs=1, batch_size=32):
        """
        Train the LSTM model on IMDB dataset.
        """
        print(f"\nüöÄ Training LSTM Model for {epochs} epochs...")

        # Callbacks
        callbacks = [
            keras.callbacks.EarlyStopping(patience=3, restore_best_weights=True),
            keras.callbacks.ReduceLROnPlateau(factor=0.5, patience=2, min_lr=0.0001)
        ]

        # Train the model
        self.nlp_history = self.nlp_model.fit(
            self.nlp_data['x_train'], self.nlp_data['y_train'],
            batch_size=batch_size,
            epochs=epochs,
            validation_data=(self.nlp_data['x_test'], self.nlp_data['y_test']),
            callbacks=callbacks,
            verbose=1
        )

        print("‚úÖ LSTM Model training completed!")

        # Evaluate model
        test_loss, test_accuracy = self.nlp_model.evaluate(
            self.nlp_data['x_test'], self.nlp_data['y_test'], verbose=0
        )
        print(f"üéØ Final Test Accuracy: {test_accuracy:.4f}")
        print(f"üéØ Final Test Loss: {test_loss:.4f}")

    def visualize_training_history(self):
        """
        Visualize training history for both models.
        """
        print("\nüìä Generating Training History Visualizations...")

        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('Model Training History', fontsize=16, fontweight='bold')

        # Image Classification Training History
        if self.img_history:
            # Accuracy plot
            axes[0, 0].plot(self.img_history.history['accuracy'], label='Train Accuracy', marker='o')
            axes[0, 0].plot(self.img_history.history['val_accuracy'], label='Val Accuracy', marker='s')
            axes[0, 0].set_title('CNN Model - Accuracy')
            axes[0, 0].set_xlabel('Epoch')
            axes[0, 0].set_ylabel('Accuracy')
            axes[0, 0].legend()
            axes[0, 0].grid(True, alpha=0.3)

            # Loss plot
            axes[0, 1].plot(self.img_history.history['loss'], label='Train Loss', marker='o')
            axes[0, 1].plot(self.img_history.history['val_loss'], label='Val Loss', marker='s')
            axes[0, 1].set_title('CNN Model - Loss')
            axes[0, 1].set_xlabel('Epoch')
            axes[0, 1].set_ylabel('Loss')
            axes[0, 1].legend()
            axes[0, 1].grid(True, alpha=0.3)

        # NLP Training History
        if self.nlp_history:
            # Accuracy plot
            axes[1, 0].plot(self.nlp_history.history['accuracy'], label='Train Accuracy', marker='o')
            axes[1, 0].plot(self.nlp_history.history['val_accuracy'], label='Val Accuracy', marker='s')
            axes[1, 0].set_title('LSTM Model - Accuracy')
            axes[1, 0].set_xlabel('Epoch')
            axes[1, 0].set_ylabel('Accuracy')
            axes[1, 0].legend()
            axes[1, 0].grid(True, alpha=0.3)

            # Loss plot
            axes[1, 1].plot(self.nlp_history.history['loss'], label='Train Loss', marker='o')
            axes[1, 1].plot(self.nlp_history.history['val_loss'], label='Val Loss', marker='s')
            axes[1, 1].set_title('LSTM Model - Loss')
            axes[1, 1].set_xlabel('Epoch')
            axes[1, 1].set_ylabel('Loss')
            axes[1, 1].legend()
            axes[1, 1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def evaluate_image_model(self):
        """
        Evaluate the CNN model and visualize results.
        """
        print("\nüìä Evaluating CNN Model...")

        # Make predictions
        y_pred = self.img_model.predict(self.img_data['x_test'])
        y_pred_classes = np.argmax(y_pred, axis=1)
        y_true = np.argmax(self.img_data['y_test'], axis=1)

        # Classification report
        print("\nüìã Classification Report (CNN):")
        print(classification_report(y_true, y_pred_classes,
                                  target_names=self.class_names_img))

        # Confusion matrix
        cm = confusion_matrix(y_true, y_pred_classes)

        plt.figure(figsize=(12, 5))

        # Confusion Matrix
        plt.subplot(1, 2, 1)
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                   xticklabels=self.class_names_img,
                   yticklabels=self.class_names_img)
        plt.title('CNN Model - Confusion Matrix')
        plt.xlabel('Predicted')
        plt.ylabel('Actual')
        plt.xticks(rotation=45)
        plt.yticks(rotation=0)

        # Prediction examples
        plt.subplot(1, 2, 2)
        # Show some correct and incorrect predictions
        correct_idx = np.where(y_pred_classes == y_true)[0][:3]
        incorrect_idx = np.where(y_pred_classes != y_true)[0][:3]

        fig, axes = plt.subplots(2, 3, figsize=(12, 8))
        fig.suptitle('CNN Predictions - Examples', fontsize=14)

        # Correct predictions
        for i, idx in enumerate(correct_idx):
            axes[0, i].imshow(self.img_data['x_test'][idx])
            axes[0, i].set_title(f'‚úì True: {self.class_names_img[y_true[idx]]}\n'
                               f'Pred: {self.class_names_img[y_pred_classes[idx]]}',
                               color='green', fontsize=10)
            axes[0, i].axis('off')

        # Incorrect predictions
        for i, idx in enumerate(incorrect_idx):
            axes[1, i].imshow(self.img_data['x_test'][idx])
            axes[1, i].set_title(f'‚úó True: {self.class_names_img[y_true[idx]]}\n'
                               f'Pred: {self.class_names_img[y_pred_classes[idx]]}',
                               color='red', fontsize=10)
            axes[1, i].axis('off')

        plt.tight_layout()
        plt.show()

    def evaluate_nlp_model(self):
        """
        Evaluate the LSTM model and visualize results.
        """
        print("\nüìä Evaluating LSTM Model...")

        # Make predictions
        y_pred = self.nlp_model.predict(self.nlp_data['x_test'])
        y_pred_binary = (y_pred > 0.5).astype(int).flatten()
        y_true = self.nlp_data['y_test']

        # Classification report
        print("\nüìã Classification Report (LSTM):")
        print(classification_report(y_true, y_pred_binary,
                                  target_names=['Negative', 'Positive']))

        # Confusion matrix and other visualizations
        cm = confusion_matrix(y_true, y_pred_binary)

        plt.figure(figsize=(15, 5))

        # Confusion Matrix
        plt.subplot(1, 3, 1)
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                   xticklabels=['Negative', 'Positive'],
                   yticklabels=['Negative', 'Positive'])
        plt.title('LSTM Model - Confusion Matrix')
        plt.xlabel('Predicted')
        plt.ylabel('Actual')

        # Prediction distribution
        plt.subplot(1, 3, 2)
        plt.hist(y_pred, bins=50, alpha=0.7, color='skyblue', edgecolor='black')
        plt.axvline(x=0.5, color='red', linestyle='--', label='Decision Threshold')
        plt.title('Prediction Score Distribution')
        plt.xlabel('Prediction Score')
        plt.ylabel('Frequency')
        plt.legend()

        # Accuracy by prediction confidence
        plt.subplot(1, 3, 3)
        confidence = np.abs(y_pred.flatten() - 0.5)
        bins = np.linspace(0, 0.5, 6)
        bin_indices = np.digitize(confidence, bins) - 1

        accuracies = []
        bin_centers = []
        for i in range(len(bins)-1):
            mask = bin_indices == i
            if np.sum(mask) > 0:
                acc = np.mean(y_true[mask] == y_pred_binary[mask])
                accuracies.append(acc)
                bin_centers.append((bins[i] + bins[i+1]) / 2)

        plt.plot(bin_centers, accuracies, marker='o', linewidth=2, markersize=8)
        plt.title('Accuracy vs Prediction Confidence')
        plt.xlabel('Prediction Confidence')
        plt.ylabel('Accuracy')
        plt.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def generate_project_report(self):
        """
        Generate a comprehensive project report.
        """
        print("\n" + "="*80)
        print("üìã DEEP LEARNING PROJECT FINAL REPORT")
        print("="*80)

        print("\nüñºÔ∏è  IMAGE CLASSIFICATION MODEL (CNN on CIFAR-10)")
        print("-" * 50)
        if self.img_model and self.img_history:
            final_train_acc = self.img_history.history['accuracy'][-1]
            final_val_acc = self.img_history.history['val_accuracy'][-1]
            final_train_loss = self.img_history.history['loss'][-1]
            final_val_loss = self.img_history.history['val_loss'][-1]

            print(f"üìä Final Training Accuracy: {final_train_acc:.4f}")
            print(f"üìä Final Validation Accuracy: {final_val_acc:.4f}")
            print(f"üìä Final Training Loss: {final_train_loss:.4f}")
            print(f"üìä Final Validation Loss: {final_val_loss:.4f}")
            print(f"üìä Total Parameters: {self.img_model.count_params():,}")

        print("\nüìù SENTIMENT ANALYSIS MODEL (LSTM on IMDB)")
        print("-" * 50)
        if self.nlp_model and self.nlp_history:
            final_train_acc = self.nlp_history.history['accuracy'][-1]
            final_val_acc = self.nlp_history.history['val_accuracy'][-1]
            final_train_loss = self.nlp_history.history['loss'][-1]
            final_val_loss = self.nlp_history.history['val_loss'][-1]

            print(f"üìä Final Training Accuracy: {final_train_acc:.4f}")
            print(f"üìä Final Validation Accuracy: {final_val_acc:.4f}")
            print(f"üìä Final Training Loss: {final_train_loss:.4f}")
            print(f"üìä Final Validation Loss: {final_val_loss:.4f}")
            print(f"üìä Total Parameters: {self.nlp_model.count_params():,}")

        print("\nüéØ PROJECT SUMMARY")
        print("-" * 50)
        print("‚úÖ Successfully implemented CNN for image classification")
        print("‚úÖ Successfully implemented LSTM for sentiment analysis")
        print("‚úÖ Generated comprehensive visualizations")
        print("‚úÖ Provided detailed model evaluations")
        print("‚úÖ Used data augmentation and callbacks for better training")
        print("‚úÖ Implemented proper data preprocessing pipelines")

        print("\nüöÄ Deep Learning Project Completed Successfully!")

def main():
    """
    Main function to run the complete deep learning project.
    """
    print("üöÄ STARTING COMPREHENSIVE DEEP LEARNING PROJECT")
    print("=" * 80)

    # Initialize project
    dl_project = DeepLearningProject()

    # IMAGE CLASSIFICATION PIPELINE
    try:
        print("\nüñºÔ∏è  STARTING IMAGE CLASSIFICATION PIPELINE...")
        dl_project.load_and_preprocess_image_data()
        dl_project.build_cnn_model()
        dl_project.train_image_model(epochs=1, batch_size=32)  # Reduced epochs for demo
    except Exception as e:
        print(f"‚ùå Error in image pipeline: {e}")

    # NLP PIPELINE
    try:
        print("\nüìù STARTING NLP PIPELINE...")
        dl_project.load_and_preprocess_nlp_data()
        dl_project.build_lstm_model()
        dl_project.train_nlp_model(epochs=1, batch_size=32)  # Reduced epochs for demo
    except Exception as e:
        print(f"‚ùå Error in NLP pipeline: {e}")

    # VISUALIZATIONS AND EVALUATIONS
    try:
        print("\nüìä GENERATING VISUALIZATIONS AND EVALUATIONS...")
        dl_project.visualize_training_history()
        dl_project.evaluate_image_model()
        dl_project.evaluate_nlp_model()
    except Exception as e:
        print(f"‚ùå Error in visualizations: {e}")

    # FINAL REPORT
    dl_project.generate_project_report()

    print("\nüéâ PROJECT COMPLETED! Check the visualizations above for detailed results.")

if __name__ == "__main__":
    main()

